<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Official V25 Bot Interface - Mode Select (Scalp/H4)</title>
  <meta name="theme-color" content="#007aff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body { font-family:'Inter',sans-serif; background:#f0f0f5; padding-top:env(safe-area-inset-top,16px); padding-bottom:env(safe-area-inset-bottom,16px); }
    .official-card{ background:#fff; padding:20px; border-radius:12px; box-shadow:0 4px 6px -1px rgba(0,0,0,.08),0 2px 4px -2px rgba(0,0,0,.05); border:1px solid #e5e5e5; }
    .ios-input{ padding:12px 16px; min-height:44px; background:#fff; border:1px solid #d1d5db; border-radius:8px; color:#1f2937; box-shadow:inset 0 1px 3px rgba(0,0,0,.06); font-size:16px; }
    .ios-input:focus{ border-color:#007aff; outline:none; box-shadow:0 0 0 3px rgba(0,122,255,.3) }
    .ios-input:disabled{ background:#f7f7f7; color:#9ca3af }
    .ios-btn-primary{ font-weight:600; border-radius:10px; min-height:48px; transition:background-color .2s, box-shadow .2s; box-shadow:0 3px 6px rgba(0,122,255,.3); }
    #log-output{ background:#f7f7f7; border:1px solid #e5e5e5 }
    .status-label{ font-size:.875rem; color:#6b7280; margin-bottom:2px }
    .status-value{ font-weight:700; color:#1f2937 }
    .text-status-active{ color:#34c759 }
    .text-status-warn{ color:#ff9500 }
    .text-status-error{ color:#ff3b30 }
    .text-status-neutral{ color:#5a5a5a }
    .pill{display:inline-block;padding:.25rem .5rem;border-radius:999px;font-weight:700;font-size:.75rem}
  </style>
</head>

<body>
  <div class="max-w-4xl mx-auto p-4 sm:p-8">
    <header class="mb-6 text-center">
      <h1 class="text-3xl font-bold text-gray-800 mb-2">V25 Bot (Mode Select)</h1>
      <p class="text-gray-500">Pick a mode â†’ bot uses that modeâ€™s rules + presets.</p>
      <p class="text-xs text-gray-400 mt-2">Trading involves risk. This tool adds guardrails but cannot guarantee profits.</p>
    </header>

    <!-- PROTECTED DEFAULTS -->
    <div class="official-card mb-6 space-y-4">
      <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center border-b pb-2 mb-2">
        <h2 class="text-xl font-semibold text-gray-700 mb-2 sm:mb-0">
          Protected Defaults
          <span id="safe-mode-indicator" class="pill text-white bg-green-500 ml-2">Safe Mode: ON</span>
          <span id="mode-pill" class="pill text-white bg-blue-500 ml-2">MODE: SCALP</span>
        </h2>

        <div class="flex space-x-2">
          <button id="unlock-settings-btn" class="text-sm py-1 px-3 bg-blue-500 text-white rounded-lg transition hover:bg-blue-600 min-h-[32px]">
            Unlock Settings ðŸ”’
          </button>
        </div>
      </div>

      <!-- MODE SELECT -->
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div class="relative">
          <label class="text-sm font-semibold text-gray-600">Mode (Bot will use this)</label>
          <select id="mode-select" class="ios-input w-full">
            <option value="SCALP">SCALP (fast tap-out)</option>
            <option value="H4">H4 RUNNER (slow + selective)</option>
          </select>
          <p class="text-xs text-gray-400 mt-1">Changing mode loads presets + rules immediately (even if Safe Mode ON).</p>
        </div>

        <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg mt-6 sm:mt-0">
          <label for="safe-mode-toggle" class="font-medium text-gray-700">Safe Mode</label>
          <input type="checkbox" id="safe-mode-toggle" checked class="form-checkbox h-5 w-5 text-green-500 rounded-full" />
        </div>
      </div>

      <!-- SETTINGS -->
      <div id="settings-area" class="space-y-4 pt-2">
        <h3 class="font-semibold text-gray-600 pt-2 border-t border-gray-100">Market & Limits</h3>

        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div class="relative">
            <input id="symbol-input" type="text" value="Volatility 25 (1s) Index" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Symbol</span>
          </div>
          <div class="relative">
            <input id="timeframe-input" type="text" value="Mode-driven (SCALP or H4)" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Logic</span>
          </div>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div class="relative">
            <input id="stake-amount" type="number" value="0.01" step="0.01" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Stake ($)</span>
          </div>
          <div class="relative">
            <input id="duration-input" type="number" value="5" step="1" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Duration</span>
          </div>
          <div class="relative">
            <input id="duration-unit-input" type="text" value="t" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Unit (t/m)</span>
          </div>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div class="relative">
            <input id="tp-input" type="number" value="0.05" step="0.01" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">TP ($ profit)</span>
          </div>
          <div class="relative">
            <input id="sl-input" type="number" value="0.05" step="0.01" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">SL ($ loss)</span>
          </div>
          <div class="relative">
            <input id="max-trades-input" type="number" value="1" step="1" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Max Trades/Signal</span>
          </div>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div class="relative">
            <input id="cooldown-input" type="number" value="2" step="1" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Cooldown (min)</span>
          </div>
          <div class="relative">
            <input id="max-loss-streak-input" type="number" value="2" step="1" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Max Loss Streak</span>
          </div>
          <div class="relative">
            <input id="daily-cap-input" type="number" value="5" step="0.5" disabled class="ios-input w-full" />
            <span class="absolute right-3 top-3 text-gray-500 text-xs pointer-events-none">Daily Loss Cap (%)</span>
          </div>
        </div>

        <p id="edit-hint" class="text-xs text-gray-400">
          Safe Mode ON: presets locked. Turn Safe Mode OFF + Unlock to edit manually.
        </p>
      </div>
    </div>

    <!-- API -->
    <div class="official-card mb-6 space-y-4">
      <h2 class="text-xl font-semibold mb-2 border-b pb-2 text-gray-700">API Connection</h2>
      <input id="api-token" type="password" placeholder="Deriv API Token (required)" class="ios-input w-full" />
      <button id="toggle-bot-btn" class="w-full py-3 text-lg ios-btn-primary bg-blue-500 text-white">Start Bot</button>
    </div>

    <!-- STATUS -->
    <div class="official-card mb-6">
      <h2 class="text-xl font-semibold mb-4 border-b pb-2 text-gray-700">Live Status Board</h2>
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div><p class="status-label">API Connection:</p><p id="connection-status" class="text-status-error status-value">DISCONNECTED</p></div>
        <div><p class="status-label">Safe Mode:</p><p id="safe-mode-status" class="text-status-active status-value">ON</p></div>
        <div><p class="status-label">Mode:</p><p id="mode-status" class="text-status-neutral status-value">SCALP</p></div>
        <div><p class="status-label">Trade Active:</p><p id="trade-active-status" class="text-status-neutral status-value">FALSE</p></div>

        <div><p class="status-label">Balance:</p><p id="current-balance-display" class="text-status-neutral status-value">$0.00</p></div>
        <div><p class="status-label">Current P/L ($):</p><p id="current-profit-display" class="text-status-neutral status-value">$0.00</p></div>
        <div><p class="status-label">Sellability:</p><p id="sellable-display" class="text-status-neutral status-value">N/A</p></div>
        <div><p class="status-label">Block Reason:</p><p id="block-reason-display" class="text-status-neutral status-value">Awaiting Start</p></div>
      </div>
    </div>

    <!-- LOG -->
    <div class="official-card p-4">
      <h2 class="text-xl font-semibold mb-3 border-b pb-2 text-gray-700">System Log</h2>
      <div id="log-output" class="p-3 h-64 overflow-y-auto text-sm rounded-lg space-y-1 text-gray-800">
        <p class="text-gray-500">[SYSTEM] Ready. Select mode, enter API Token, click Start.</p>
      </div>
    </div>
  </div>

  <!-- MODAL -->
  <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
    <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full space-y-4" role="dialog" aria-modal="true">
      <h3 id="modal-title" class="text-lg font-bold text-red-600">Confirmation Required</h3>
      <p id="modal-message" class="text-gray-700">Are you sure?</p>
      <input type="text" id="modal-input" placeholder="Type UNLOCK" class="ios-input w-full hidden" />
      <div class="flex justify-end space-x-3">
        <button id="modal-cancel-btn" class="py-2 px-4 text-gray-600 rounded-lg hover:bg-gray-100">Cancel</button>
        <button id="modal-confirm-btn" class="py-2 px-4 bg-red-500 text-white rounded-lg hover:bg-red-600">Confirm</button>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // DERIV CONFIG
    // =========================
    const APP_ID = 1089;
    const SYMBOL = "R_25";
    const API_URL = `wss://ws.binaryws.com/websockets/v3?app_id=${APP_ID}`;

    // =========================
    // MODE PRESETS (THIS IS THE KEY)
    // =========================
    const MODE_PRESETS = {
      SCALP: {
        modeName: "SCALP",
        stakeAmount: 0.01,
        duration: 5,
        durationUnit: "t",   // ticks
        tp: 0.05,            // profit dollars (fast tap-out)
        sl: 0.05,            // loss dollars
        maxTradesPerSignal: 1,
        cooldownMin: 2,
        entryStyle: "FAST"   // tick-based
      },
      H4: {
        modeName: "H4",
        stakeAmount: 0.01,
        duration: 1,
        durationUnit: "m",   // minutes so itâ€™s usually sellable earlier than tiny tick contracts
        tp: 0.20,
        sl: 0.10,
        maxTradesPerSignal: 2,
        cooldownMin: 3,
        entryStyle: "SLOW"   // needs H4 signal + retest
      }
    };

    // =========================
    // STATE
    // =========================
    let state = {
      ws: null,
      isBotRunning: false,
      apiToken: "",

      mode: "SCALP",            // default
      safeMode: true,
      settingsLocked: true,

      // execution values
      stakeAmount: MODE_PRESETS.SCALP.stakeAmount,
      duration: MODE_PRESETS.SCALP.duration,
      durationUnit: MODE_PRESETS.SCALP.durationUnit,
      tpUSD: MODE_PRESETS.SCALP.tp,
      slUSD: MODE_PRESETS.SCALP.sl,
      maxTradesPerSignal: MODE_PRESETS.SCALP.maxTradesPerSignal,
      cooldownDuration: MODE_PRESETS.SCALP.cooldownMin * 60,
      maxLossStreak: 2,
      dailyLossCapPercent: 5,

      // live data
      currentBalance: 0,
      initialDailyBalance: 0,
      dailyProfitLossUSD: 0,
      lossStreak: 0,
      cooldown: false,
      blockReason: "Awaiting Start",

      // entry signal / management
      bias: "",
      breakoutLevel: 0,
      breakoutStrength: 0,
      tradeCounter: 0,

      // contract tracking
      activeContract: null,
      activeContractId: null,

      // IMPORTANT GUARDS
      entryInProgress: false,
      closeRequestedForContractId: null, // prevents repeated sell spam
      subs: {
        balance: { subscribed:false, subscribing:false },
        poc: { subscribed:false, subscribing:false },
        ticks: { subscribed:false, subscribing:false }
      },

      logicInterval: null
    };

    // =========================
    // DOM
    // =========================
    const modeSelect = document.getElementById("mode-select");
    const modePill = document.getElementById("mode-pill");

    const tokenInput = document.getElementById("api-token");
    const safeModeToggle = document.getElementById("safe-mode-toggle");
    const safeModeIndicator = document.getElementById("safe-mode-indicator");
    const unlockBtn = document.getElementById("unlock-settings-btn");
    const toggleBtn = document.getElementById("toggle-bot-btn");

    const stakeInput = document.getElementById("stake-amount");
    const durationInput = document.getElementById("duration-input");
    const durationUnitInput = document.getElementById("duration-unit-input");
    const tpInput = document.getElementById("tp-input");
    const slInput = document.getElementById("sl-input");
    const maxTradesInput = document.getElementById("max-trades-input");
    const cooldownInput = document.getElementById("cooldown-input");
    const maxLossStreakInput = document.getElementById("max-loss-streak-input");
    const dailyCapInput = document.getElementById("daily-cap-input");
    const editHint = document.getElementById("edit-hint");

    const logOutput = document.getElementById("log-output");
    const status = {
      connection: document.getElementById("connection-status"),
      safeMode: document.getElementById("safe-mode-status"),
      mode: document.getElementById("mode-status"),
      active: document.getElementById("trade-active-status"),
      balance: document.getElementById("current-balance-display"),
      profit: document.getElementById("current-profit-display"),
      sellable: document.getElementById("sellable-display"),
      block: document.getElementById("block-reason-display"),
    };

    // modal
    const modalOverlay = document.getElementById("modal-overlay");
    const modalTitle = document.getElementById("modal-title");
    const modalMessage = document.getElementById("modal-message");
    const modalInput = document.getElementById("modal-input");
    const modalCancelBtn = document.getElementById("modal-cancel-btn");
    const modalConfirmBtn = document.getElementById("modal-confirm-btn");

    // =========================
    // UI HELPERS
    // =========================
    function log(message, type="info"){
      const now = new Date().toLocaleTimeString();
      let cls = "text-gray-500";
      if(type==="error") cls="text-status-error";
      if(type==="success") cls="text-status-active";
      if(type==="warn") cls="text-status-warn";
      if(type==="action") cls="text-blue-500";
      const p = document.createElement("p");
      p.className = cls;
      p.textContent = `[${now}] [${type.toUpperCase()}] ${message}`;
      logOutput.prepend(p);
      if(logOutput.children.length>100) logOutput.removeChild(logOutput.lastChild);
    }

    function showModal(title,msg,requiresInput,onConfirm,onCancel){
      modalTitle.textContent=title;
      modalMessage.textContent=msg;
      modalInput.classList.toggle("hidden", !requiresInput);
      modalInput.value="";
      modalOverlay.classList.remove("hidden"); modalOverlay.classList.add("flex");

      modalConfirmBtn.onclick=()=>{
        if(requiresInput && modalInput.value!=="UNLOCK"){
          log("Wrong confirmation text.","error"); return;
        }
        modalOverlay.classList.add("hidden"); modalOverlay.classList.remove("flex");
        onConfirm && onConfirm();
      };
      modalCancelBtn.onclick=()=>{
        modalOverlay.classList.add("hidden"); modalOverlay.classList.remove("flex");
        onCancel && onCancel();
      };
    }

    function setMode(modeKey){
      state.mode = modeKey;
      const preset = MODE_PRESETS[modeKey];

      // Always load presets (THIS is what you asked)
      state.stakeAmount = preset.stakeAmount;
      state.duration = preset.duration;
      state.durationUnit = preset.durationUnit;
      state.tpUSD = preset.tp;
      state.slUSD = preset.sl;
      state.maxTradesPerSignal = preset.maxTradesPerSignal;
      state.cooldownDuration = preset.cooldownMin * 60;

      // If SafeMode ON -> keep locked and reflect preset in UI
      if(state.safeMode){
        state.settingsLocked = true;
      }

      // reset â€œin-progressâ€ flags safely
      state.entryInProgress = false;
      state.closeRequestedForContractId = null;

      // reflect in UI
      stakeInput.value = state.stakeAmount.toFixed(2);
      durationInput.value = state.duration;
      durationUnitInput.value = state.durationUnit;
      tpInput.value = state.tpUSD.toFixed(2);
      slInput.value = state.slUSD.toFixed(2);
      maxTradesInput.value = state.maxTradesPerSignal;
      cooldownInput.value = (state.cooldownDuration/60).toFixed(0);

      modePill.textContent = `MODE: ${preset.modeName}`;
      status.mode.textContent = preset.modeName;

      log(`Mode set to ${preset.modeName}. Bot will use these rules now.`, "action");
      applyLockState();
      updateUI();
    }

    function syncFromUI_ifManualAllowed(){
      // Only allow manual edits when SafeMode OFF + Unlocked
      const manualAllowed = (!state.safeMode && !state.settingsLocked);
      if(!manualAllowed) return;

      state.stakeAmount = parseFloat(stakeInput.value) || state.stakeAmount;
      state.duration = parseInt(durationInput.value) || state.duration;
      state.durationUnit = (durationUnitInput.value || state.durationUnit).trim();
      state.tpUSD = parseFloat(tpInput.value) || state.tpUSD;
      state.slUSD = parseFloat(slInput.value) || state.slUSD;
      state.maxTradesPerSignal = parseInt(maxTradesInput.value) || state.maxTradesPerSignal;
      state.cooldownDuration = (parseFloat(cooldownInput.value)|| (state.cooldownDuration/60)) * 60;
      state.maxLossStreak = parseInt(maxLossStreakInput.value) || state.maxLossStreak;
      state.dailyLossCapPercent = parseFloat(dailyCapInput.value) || state.dailyLossCapPercent;
    }

    function applyLockState(){
      const manualAllowed = (!state.safeMode && !state.settingsLocked);

      const inputs = [
        stakeInput, durationInput, durationUnitInput, tpInput, slInput,
        maxTradesInput, cooldownInput, maxLossStreakInput, dailyCapInput
      ];

      inputs.forEach(i => i.disabled = true);
      if(manualAllowed) inputs.forEach(i => i.disabled = false);

      if(state.safeMode){
        unlockBtn.textContent = "Safe Mode ON (Locked) âœ…";
        unlockBtn.className = "text-sm py-1 px-3 bg-green-500 text-white rounded-lg transition min-h-[32px]";
        editHint.textContent = "Safe Mode ON: presets locked. Turn Safe Mode OFF + Unlock to edit manually.";
      } else {
        unlockBtn.textContent = state.settingsLocked ? "Unlock Settings ðŸ”’" : "Settings Unlocked ðŸ”“";
        unlockBtn.className = state.settingsLocked
          ? "text-sm py-1 px-3 bg-blue-500 text-white rounded-lg transition hover:bg-blue-600 min-h-[32px]"
          : "text-sm py-1 px-3 bg-red-500 text-white rounded-lg transition hover:bg-red-600 min-h-[32px]";
        editHint.textContent = manualAllowed
          ? "Manual editing ACTIVE (Safe Mode OFF + Unlocked)."
          : "Safe Mode OFF: click Unlock to edit manual values.";
      }
    }

    function updateUI(){
      status.safeMode.textContent = state.safeMode ? "ON" : "OFF";
      status.active.textContent = state.activeContract ? "TRUE" : "FALSE";
      status.balance.textContent = `$${(state.currentBalance||0).toFixed(2)}`;

      const profit = state.activeContract ? (parseFloat(state.activeContract.profit)||0) : 0;
      status.profit.textContent = `$${profit.toFixed(2)}`;

      // sellability display
      if(state.activeContract){
        const sellable = (state.activeContract.is_sellable === 1);
        status.sellable.textContent = sellable ? "SELLABLE âœ…" : "EXPIRY-ONLY âŒ";
        status.sellable.className = sellable ? "text-status-active status-value" : "text-status-warn status-value";
      } else {
        status.sellable.textContent = "N/A";
        status.sellable.className = "text-status-neutral status-value";
      }

      status.block.textContent = state.blockReason;

      toggleBtn.textContent = state.isBotRunning ? "Stop Bot (Running)" : "Start Bot";
      toggleBtn.className = state.isBotRunning
        ? "w-full py-3 text-lg ios-btn-primary bg-red-500 hover:bg-red-600 text-white"
        : "w-full py-3 text-lg ios-btn-primary bg-blue-500 hover:bg-blue-600 text-white";
    }

    // =========================
    // SUBSCRIPTION GUARDS
    // =========================
    function resetSubs(){
      Object.keys(state.subs).forEach(k => {
        state.subs[k].subscribed = false;
        state.subs[k].subscribing = false;
      });
    }
    function send(req){
      if(!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
      state.ws.send(JSON.stringify(req));
    }
    function subscribeBalanceOnce(){
      if(state.subs.balance.subscribed || state.subs.balance.subscribing) return;
      state.subs.balance.subscribing = true;
      send({ balance: 1, subscribe: 1 });
      log("Balance stream subscribed (guarded).", "info");
    }
    function subscribePOCOnce(){
      if(state.subs.poc.subscribed || state.subs.poc.subscribing) return;
      state.subs.poc.subscribing = true;
      send({ proposal_open_contract: 1, subscribe: 1 });
      log("Open-contract stream subscribed (guarded).", "info");
    }
    function subscribeTicksOnce(){
      if(state.subs.ticks.subscribed || state.subs.ticks.subscribing) return;
      state.subs.ticks.subscribing = true;
      send({ ticks: SYMBOL, subscribe: 1 });
      log("Tick stream subscribed (guarded).", "info");
    }

    // =========================
    // BASIC ENTRY SIGNAL
    // (kept simple + stable; mode controls how aggressive)
    // =========================
    function requestH4Candles(){
      send({
        ticks_history: SYMBOL,
        end: "latest",
        count: 3,
        granularity: 14400,
        style: "candles"
      });
    }

    function detectH4Structure(candle){
      const close = parseFloat(candle.close), open = parseFloat(candle.open);
      const high = parseFloat(candle.high), low = parseFloat(candle.low);
      const range = Math.max(1e-9, high-low);
      const body = Math.abs(close-open);
      const bodyRatio = body/range;

      const bullish = (close>open) && (close >= open + range*0.6);
      const bearish = (close<open) && (close <= open - range*0.6);

      let newBias="", newLevel=0;
      if(bullish){ newBias="bullish"; newLevel=high; }
      if(bearish){ newBias="bearish"; newLevel=low; }

      if(newBias && (newBias!==state.bias || newLevel!==state.breakoutLevel)){
        state.bias = newBias;
        state.breakoutLevel = newLevel;
        state.breakoutStrength = Math.min(1, Math.max(0, bodyRatio));
        state.tradeCounter = 0;
        state.entryInProgress = false;
        log(`H4 Signal: ${newBias.toUpperCase()} | Level ${newLevel.toFixed(4)} | Strength ${(state.breakoutStrength*100).toFixed(0)}%`, "success");
      }
    }

    function validRetestTick(price){
      const tol = Math.max(0.0003, price * 0.00008);
      return state.bias && state.breakoutLevel && (Math.abs(price - state.breakoutLevel) <= tol);
    }

    // =========================
    // TRADE FLOW (proposal -> buy)
    // =========================
    function takeTrade(bias){
      if(!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
      if(state.entryInProgress) return;

      state.entryInProgress = true;

      const contract_type = (bias==="bullish") ? "CALL" : "PUT";

      const proposalReq = {
        proposal: 1,
        amount: state.stakeAmount,
        basis: "stake",
        contract_type,
        currency: "USD",
        duration: state.duration,
        duration_unit: state.durationUnit,
        symbol: SYMBOL
      };

      const handler = (evt) => {
        const data = JSON.parse(evt.data);
        if(data.error){
          log(`Proposal error: ${data.error.message}`, "error");
          state.entryInProgress = false;
          state.ws.removeEventListener("message", handler);
          return;
        }
        if(data.msg_type === "proposal" && data.proposal?.id){
          send({ buy: data.proposal.id, price: state.stakeAmount });
          log(`BUY sent (${contract_type}) stake $${state.stakeAmount.toFixed(2)} | ${state.duration}${state.durationUnit}`, "action");
          state.ws.removeEventListener("message", handler);
        }
      };

      state.ws.addEventListener("message", handler);
      send(proposalReq);
    }

    // =========================
    // CLOSE GUARD + SELLABILITY CHECK
    // =========================
    function closePosition(reason){
      const c = state.activeContract;
      if(!c || !c.contract_id) return;

      // Stop repeated sell spam
      if(state.closeRequestedForContractId === c.contract_id) return;

      // If not sellable, do NOT try sell (prevents your errors)
      if(c.is_sellable !== 1){
        state.closeRequestedForContractId = c.contract_id; // prevents repeated attempts
        log(`Not sellable (expiry-only). Will let it expire. Reason: ${reason}`, "warn");
        return;
      }

      state.closeRequestedForContractId = c.contract_id;
      send({ sell: c.contract_id, price: 0 });
      log(`Close requested: ${reason}`, "warn");
    }

    function runTradeManagement(){
      const c = state.activeContract;
      if(!c) return;

      const profit = parseFloat(c.profit || 0);
      const tp = state.tpUSD;
      const sl = -Math.abs(state.slUSD);

      // Fast tap-out logic (both modes still use profit-based TP/SL)
      if(profit >= tp){
        closePosition(`TP Hit (+$${profit.toFixed(2)})`);
      } else if(profit <= sl){
        closePosition(`SL Hit ($${profit.toFixed(2)})`);
      }
    }

    function handleTradeClose(c){
      const buy = parseFloat(c.buy_price||0);
      const sell = parseFloat(c.sell_price||0);
      const pnl = sell - buy;

      state.dailyProfitLossUSD += pnl;
      state.activeContract = null;
      state.activeContractId = null;
      state.entryInProgress = false;
      state.closeRequestedForContractId = null;

      if(pnl < 0){
        state.lossStreak++;
        log(`TRADE CLOSED LOSS: $${pnl.toFixed(2)} | Streak ${state.lossStreak}/${state.maxLossStreak}`, "error");
      } else {
        state.lossStreak = 0;
        log(`TRADE CLOSED PROFIT: +$${pnl.toFixed(2)}`, "success");
      }

      if(state.lossStreak >= state.maxLossStreak){
        state.cooldown = true;
        log(`Cooldown started: ${(state.cooldownDuration/60).toFixed(0)} min`, "warn");
        setTimeout(()=>{
          state.cooldown = false;
          state.lossStreak = 0;
          log("Cooldown finished. Ready.", "info");
          updateUI();
        }, state.cooldownDuration * 1000);
      }
    }

    // =========================
    // MESSAGE HANDLER
    // =========================
    function handleMessage(data){
      if(data?.error?.message?.includes("already subscribed to balance")){
        state.subs.balance.subscribed=true; state.subs.balance.subscribing=false;
        log("Balance already subscribed (ignored).", "warn");
        return;
      }

      if(data.msg_type==="authorize" && data.authorize){
        log(`Authorized: ${data.authorize.loginid}`, "success");
        state.currentBalance = parseFloat(data.authorize.balance||0);
        if(!state.initialDailyBalance) state.initialDailyBalance = state.currentBalance;

        subscribeBalanceOnce();
        subscribePOCOnce();
        subscribeTicksOnce();

        startLogicLoop();
        updateUI();
        return;
      }

      if(data.msg_type==="balance" && data.balance){
        state.subs.balance.subscribed=true; state.subs.balance.subscribing=false;
        state.currentBalance = parseFloat(data.balance.balance);
        updateUI();
        return;
      }

      if(data.msg_type==="ticks_history" && data.candles?.length){
        const h4 = data.candles[data.candles.length-1];
        detectH4Structure(h4);
        return;
      }

      if(data.msg_type==="tick" && data.tick){
        state.subs.ticks.subscribed=true; state.subs.ticks.subscribing=false;
        const px = parseFloat(data.tick.quote);

        // ENTRY RULES BY MODE
        if(state.isBotRunning && !state.cooldown && !state.activeContract && !state.entryInProgress){
          // SCALP: enter faster (requires at least bias; if no bias yet, keep waiting)
          if(state.mode==="SCALP"){
            if(state.bias && validRetestTick(px) && state.tradeCounter < state.maxTradesPerSignal){
              state.blockReason = "SCALP: retest hit â†’ entering";
              takeTrade(state.bias);
            } else {
              state.blockReason = state.bias ? "SCALP: waiting retest" : "SCALP: waiting H4 bias";
            }
          }

          // H4: more strict (needs bias + decent strength)
          if(state.mode==="H4"){
            const strongEnough = state.breakoutStrength >= 0.65;
            if(state.bias && strongEnough && validRetestTick(px) && state.tradeCounter < state.maxTradesPerSignal){
              state.blockReason = "H4: strong retest â†’ entering";
              takeTrade(state.bias);
            } else {
              state.blockReason = state.bias ? "H4: waiting strong retest" : "H4: waiting H4 breakout";
            }
          }
        }

        // MANAGEMENT
        if(state.activeContract) runTradeManagement();
        updateUI();
        return;
      }

      if(data.msg_type==="proposal_open_contract" && data.proposal_open_contract){
        state.subs.poc.subscribed=true; state.subs.poc.subscribing=false;
        const c = data.proposal_open_contract;

        // track contract
        state.activeContract = c;
        state.activeContractId = c.contract_id || state.activeContractId;

        // increment trades once contract truly exists
        if(c.contract_id && state.tradeCounter===0 && !c.is_sold){
          // do nothing here; buy handler increments
        }

        if(c.is_sold){
          handleTradeClose(c);
          state.tradeCounter = Math.min(state.maxTradesPerSignal, state.tradeCounter + 1);
        }
        updateUI();
        return;
      }

      if(data.msg_type==="buy" && data.buy){
        state.activeContractId = data.buy.contract_id;
        state.tradeCounter++;
        log(`TRADE BOUGHT: Contract ${state.activeContractId}`, "success");
        updateUI();
        return;
      }
    }

    // =========================
    // CONNECT / LOOP
    // =========================
    function connect(){
      if(state.ws && (state.ws.readyState===WebSocket.OPEN || state.ws.readyState===WebSocket.CONNECTING)) return;

      state.apiToken = tokenInput.value.trim();
      if(!state.apiToken){ log("API Token is required.", "error"); return; }

      log("Connecting to Deriv API...", "info");
      state.ws = new WebSocket(API_URL);

      state.ws.onopen = () => {
        resetSubs();
        status.connection.textContent = "CONNECTED";
        status.connection.className = "text-status-active status-value";
        send({ authorize: state.apiToken });
      };

      state.ws.onmessage = (evt) => {
        const data = JSON.parse(evt.data);
        if(data.error){
          log(`API Error: ${data.error.message}`, "error");
          if(/invalid token/i.test(data.error.message)) stopBot("Invalid token.");
          return;
        }
        handleMessage(data);
      };

      state.ws.onclose = () => {
        status.connection.textContent = "DISCONNECTED";
        status.connection.className = "text-status-error status-value";
        state.ws = null;
        resetSubs();
        stopLogicLoop();
        state.isBotRunning = false;
        updateUI();
        log("Connection closed.", "warn");
      };
    }

    function startLogicLoop(){
      if(state.logicInterval) return;
      mainLogic();
      state.logicInterval = setInterval(mainLogic, 60000);
      log("Main logic loop started (60s).", "info");
    }
    function stopLogicLoop(){
      if(state.logicInterval){ clearInterval(state.logicInterval); state.logicInterval=null; }
    }

    function mainLogic(){
      if(!state.isBotRunning) return;

      // allow manual edits only if SafeMode OFF + Unlocked
      syncFromUI_ifManualAllowed();

      // request H4 candles to keep bias updated (both modes use bias)
      requestH4Candles();

      // simple risk checks
      if(state.cooldown){ state.blockReason="Cooldown Active"; updateUI(); return; }
      if(state.activeContract){ state.blockReason="Trade Active - Managing"; updateUI(); return; }
      if(state.tradeCounter >= state.maxTradesPerSignal){ state.blockReason="Trade limit reached"; updateUI(); return; }

      updateUI();
    }

    function toggleBot(){
      syncFromUI_ifManualAllowed();

      if(!state.isBotRunning){
        state.isBotRunning = true;
        log(`Bot started | MODE: ${state.mode} | Stake: $${state.stakeAmount.toFixed(2)} | Dur: ${state.duration}${state.durationUnit}`, "info");
        connect();
        startLogicLoop();
      } else {
        stopBot("Manual stop.");
      }
      updateUI();
    }

    function stopBot(reason){
      state.isBotRunning=false;
      stopLogicLoop();
      state.activeContract=null;
      state.activeContractId=null;
      state.entryInProgress=false;
      state.closeRequestedForContractId=null;
      state.tradeCounter=0;
      log(`Bot stopped: ${reason}`, "warn");
      if(state.ws && state.ws.readyState===WebSocket.OPEN) state.ws.close();
      state.ws=null;
      resetSubs();
      updateUI();
    }

    // =========================
    // SAFE MODE / UNLOCK
    // =========================
    function handleUnlock(){
      if(state.safeMode){
        log("Unlock blocked: Turn Safe Mode OFF first.", "error");
        showModal("Safe Mode ON", "Turn Safe Mode OFF first. Manual editing allowed only when Safe Mode is OFF.", false, null, null);
        return;
      }
      showModal("Unlock Settings", "Type UNLOCK to enable manual editing.", true, ()=>{
        state.settingsLocked = false;
        applyLockState();
        log("Settings unlocked. Manual values editable.", "warn");
      }, ()=>{});
    }

    function handleSafeModeToggle(){
      if(safeModeToggle.checked){
        state.safeMode = true;
        state.settingsLocked = true;
        safeModeIndicator.textContent="Safe Mode: ON";
        safeModeIndicator.classList.remove("bg-red-500"); safeModeIndicator.classList.add("bg-green-500");
        log("Safe Mode ENABLED. Presets locked.", "success");

        // reload current mode preset (ensures it stays â€œwhat the bot usesâ€)
        setMode(state.mode);
      } else {
        showModal("WARNING: Safe Mode OFF", "Safe Mode OFF uses ONLY your manual values. Continue?", false, ()=>{
          state.safeMode=false;
          safeModeIndicator.textContent="Safe Mode: OFF";
          safeModeIndicator.classList.remove("bg-green-500"); safeModeIndicator.classList.add("bg-red-500");
          log("Safe Mode DISABLED. You may unlock to edit manual values.", "warn");
          applyLockState();
          updateUI();
        }, ()=>{
          safeModeToggle.checked=true;
        });
      }
      applyLockState();
      updateUI();
    }

    // =========================
    // EVENTS
    // =========================
    toggleBtn.addEventListener("click", toggleBot);
    unlockBtn.addEventListener("click", handleUnlock);
    safeModeToggle.addEventListener("change", handleSafeModeToggle);

    modeSelect.addEventListener("change", (e)=>{
      const next = e.target.value;
      setMode(next);
    });

    document.addEventListener("DOMContentLoaded", ()=>{
      // default mode
      modeSelect.value = "SCALP";
      setMode("SCALP");

      applyLockState();
      updateUI();
      log("Initialization complete.", "info");
    });
  </script>
</body>
</html>
